---
title: "Transcriptomal Changes in NPCs Following Exposure to Spinal Cord Injury"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document:
    theme: flatly
    toc: true
    number_sections: true
    toc_float:
      collapsed: false
      smooth_scroll: false

---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

***

# Executive Summary

* Samples 101-108 + 111 have double peaks in density of log-cpm plots. 101-108 had low alignment rates and 111 is a definite outlier in the MDS. Samples 101-108 and 111 are therefore removed. 

***

# Project Description

**Hypothesis:** 

**Experimental setup & sequencing:** 

**Data analysis:** Data was analysed using edgeR and limma packages, both available through [Bioconductor](https://www.bioconductor.org/) using R (version 3.4.4, *Someone to Lean On*). Two additional key packages used were ggplot2 and data.table.    

***

# Data Overview

```{r echo=F, warning=F, error=F, message=F}
#1. Installing packages
# source("https://bioconductor.org/biocLite.R")
# biocLite("limma")

# source("https://bioconductor.org/biocLite.R")
# biocLite("edgeR")

# source("https://bioconductor.org/biocLite.R")
# biocLite("Rattus.norvegicus")

#install.packages("data.table")
#install.packages("ggplot2")
#install.packages("cowplot")
#install.packages("RColorBrewer")
#install.packages("gplots")
#install.packages("pvclust")
#install.packages("VennDiagram")
# install.packages("rafalib")
#install.packages("grid")
#install.packages("colorspace")
#install.packages("ellipse")
#install.packages("ggrepel")
#install.packages("rafalib")
#install.packages("boot")
#install.packages("pvclust")
#install.packages("RCurl")
#install.packages("XML")
#install.packages("xml2")
#install.packages("caret")
#install.packages("Rtsne")
#install.packages("plot3D")
#install.packages("EMCluster")
#install.packages("MeanShift")
#install.packages("apcluster")
#install.packages("e1071")
#install.packages("circlize")

#Installation guide for ggraph
  #sudo apt-get -y install libcurl4-gnutls-dev
  #sudo apt-get -y install libssl-dev
  #install.packages("devtools")
  #sudo apt-get install libudunits2-dev
  # install.packages('udunits2', type = "source",
  #                    configure.args=c('--with-udunits2-lib=/home/ramhak/R/x86_64-pc-linux-gnu-library/3.4'))
  #devtools::install_github("thomasp85/ggraph", dependencies=TRUE, force=T)
  #devtools::install_github('tidyverse/ggplot2', dependencies=T, force=T) #Get the development version of ggplot2
  #library(ggplot2)

#2. Attaching packages
library(limma)
library(edgeR)
library(Rattus.norvegicus)

library(data.table)
library(ggplot2)
library(cowplot)
library(gridExtra)
library(grid)

library(colorspace)
library(RColorBrewer)
library(gplots)
library(VennDiagram)
library(ellipse)
library(plot3D)
library(ggrepel)
library(rafalib)

library(boot)
library(pvclust)

library(knitr)
library(pander)

library(RCurl)
library(XML)
library(xml2)

library(caret)
library(Rtsne)

library(MASS)
library(mda)
library(kernlab)
library(EMCluster)
library(MeanShift)
library(apcluster)
library(e1071)

library(ggraph)
library(igraph)
library(ape)
library(circlize)

#Clearing workspace
rm(list=ls())

#Importing function for legend collection from ggplot 
source("/home/ramhak/Dropbox/PHD/PAPER I/R_v2/Function_directory/get_legend.R")
```

```{r echo=F, warning=F, message=F, error=F}
############## IMPORTING DATA, ANNOTATING GENES & ORGANISING META DATA #############
```

**Table 1. Data set characteristics.**

```{r echo=F, warning=F, error=F, message=F}
#1. Importing read count matrix
DT_read_count <- fread("merged_gene_counts.txt", header=T)
############################### REMOVING 101:108 & 111
DT_read_count[, c(2:9, 12):=NULL]
#2. Adjusting column names 
names(DT_read_count) <- c(names(DT_read_count)[1], do.call(rbind, lapply(names(DT_read_count)[2:length(names(DT_read_count))], function(col_name){substr(col_name, 7, 9)})))
#3. Retrieving gene annotations (SYMBOL) based on ENSEMBL_ID
gene_annotations <- suppressMessages(data.table(OrganismDbi::select(Rattus.norvegicus, keys=DT_read_count[,as.character(ENSEMBL_ID)], columns="SYMBOL", keytype = "ENSEMBL")))
#4. Removing duplicates in retrieved annotations
gene_annotations <- gene_annotations[!duplicated(ENSEMBL)]
#5. Merging gene annotations with read_count_matrix 
DT_read_count <- merge(DT_read_count, gene_annotations, by.x="ENSEMBL_ID", by.y="ENSEMBL")
DT_read_count <- setcolorder(DT_read_count, c(1, 21, 2:20))
#6. Importing meta_data
DT_meta_data <- fread("meta_data.csv")
DT_meta_data <- DT_meta_data[!Scilife.index%in%c(101:108, 111)]
#7. Adjusting meta_data
DT_meta_data[, `:=`(Cell=NULL, Index=NULL, Sample_name=NULL)]
setnames(DT_meta_data, c("Scilife.index", "Treatment"), c("ID", "group"))
DT_meta_data[Week==0, Week:=NA]
DT_meta_data[group=="None", group:="invitro"]
#8. Creating time-group variable in meta_data
DT_meta_data[group!="invitro", group:=paste(paste(group, Week, sep=":"), "W", sep="")]
#9. Adding library size (=column sums)
DT_meta_data <- DT_meta_data[,library.size:=colSums(DT_read_count[,-(1:2)])]
#8. Adding normalisation factor (=1 initially)
DT_meta_data <- DT_meta_data[,norm.factor:=1]
#9. Defining factor variables
factor_vars <- c("ID", "group")
DT_meta_data[,factor_vars] <- DT_meta_data[,lapply(.SD, factor), .SDcols=factor_vars]

###SECTION OUTPUT
#Table with dataset characteristics
pander(data.table(Characteristic=c("Samples (n):","Groups (n):","Unique ENSEMBL IDs (n):"), Value= c(ncol(DT_read_count[,-(1:2)]), length(unique(DT_meta_data[,group])), nrow(DT_read_count))), justify=c("left", "left"))

```

***

# Data Pre-Processing

## *Removing genes with low expression*

**Fig 1. Density of log-CPM values pre -and post filtering**

```{r echo=F, warning=F, message=F, error=F, fig.height=5, fig.width=13}
#1. Converting the read count matrix into a log CPM matrix 
DT_lcpm_unfiltered <- data.table(cpm(DT_read_count[,-c(1:2)], log=T, lib.size = colSums(DT_read_count[,-c(1:2)])))
#2. Filtering out lowly expressed genes from read count matrix using log-CPM values
DT_read_count_filtered <- DT_read_count[rowSums(DT_lcpm_unfiltered>0)>=4]
#3. Calculating log CPM matrix using the filtered read count matrix
DT_lcpm <- cpm(DT_read_count_filtered[,-c(1:2)], log=T, lib.size = colSums(DT_read_count_filtered[,-c(1:2)]))
#4. Melting data for plotting
lcpm_unfiltered_plotdata <- suppressWarnings(melt.data.table(data.table(DT_lcpm_unfiltered), variable.name="ID", value.name = "lcpm"))
lcpm_filtered_plotdata <- suppressWarnings(melt.data.table(data.table(DT_lcpm), variable.name="ID", value.name = "lcpm"))

#5. Plotting function (density against log-CPM values)
logCPM_density_plot_function <- function(plot.data, type, legend.type){
  logCPM_density_plot_out <- ggplot(plot.data, aes(x=lcpm, color=ID))+
  geom_line(stat="density", size=1.25)+
  geom_vline(xintercept=0, linetype=2)+

  scale_x_continuous(breaks=seq(-10,16,2), limits=c(-8,16))+
  scale_y_continuous(breaks=seq(0,0.6,0.05), limits=c(0,0.6))+
  scale_color_manual(values=diverge_hcl(28, c=100, l=c(50,90), power=1))+
  annotate(geom="text", x=5, y=0.55, label=type, size=7.5, alpha=0.6)+
  annotate(geom="text", x=5, y=0.5, label=paste("Genes (n):", toString(unique(plot.data[,.N, by="ID"][,N]))), fontface=2, size=4)+
  theme(legend.position=legend.type, axis.title=element_blank())
  
  return(logCPM_density_plot_out)  
}

density_raw_plot <- logCPM_density_plot_function(lcpm_unfiltered_plotdata, "RAW","right")
density_legend <- get_legend(density_raw_plot)
density_raw_plot <- logCPM_density_plot_function(lcpm_unfiltered_plotdata, "RAW","none")
density_filtered_plot <- logCPM_density_plot_function(lcpm_filtered_plotdata, "FILTERED","none")

###SECTION OUTPUT
grid.arrange(arrangeGrob(density_raw_plot, left=textGrob("A", vjust=-10, hjust=1.5, gp=gpar(fontface=2, fontsize=20))), arrangeGrob(density_filtered_plot, left=textGrob("B", vjust=-10, hjust=1.5, gp=gpar(fontface=2, fontsize=20))), ncol=2, widths=c(3,3), bottom=textGrob("log-CPM", gp=gpar(fontsize=17, fontface="bold")), left=textGrob("Density", gp=gpar(fontsize=17, fontface="bold"), rot=90))

```

**Fig 1.** _Figure reports the density of log-CPM for every sample (by color) pre -and post filtering of genes with low expression. The raw read count matrix is filtered based on log-CPM values. Vertical dashed line represents the cut-off (log-CPM=0, CPM=1). The figure shows a distinct shift of the density from below the threshold (Fig 1A) to above the threshold (Fig 1B). Approximately 1/3 of the genes remain post filtering._  

***

## *Adjusting gene expression distributions*

```{r echo=F, warning=F, message=F, error=F}
#1. Calculating normalization factors using TMM algorithm and adding to meta_data
DT_meta_data <- DT_meta_data[,norm.factor.tmm:=calcNormFactors(DT_read_count_filtered[,-(1:2)], method = "TMM")]
#2. Calculating adjusted library sizes in meta_data
DT_meta_data <- DT_meta_data[,effective.library.size:=library.size*norm.factor.tmm]
```

**Fig 2. Distribution of log-CPM values pre -and post normalization**

```{r echo=F, warning=F, message=F, error=F, fig.height=5, fig.width=12}
#1. Calculating log2 of read_count_matrix with unadjusted and adjusted library size respectively
lcpm_temp_notNormalised <- cpm(DT_read_count_filtered[,-(1:2)], log=T, lib.size = DT_meta_data[,library.size])
lcpm_temp <- cpm(DT_read_count_filtered[,-(1:2)], log=T, lib.size = DT_meta_data[,effective.library.size])
#2. Adding id columns and converting into data.table
DT_lcpm_notNormalised <- data.table(DT_read_count_filtered[,c(1:2)], lcpm_temp_notNormalised)
DT_lcpm <- data.table(DT_read_count_filtered[,c(1:2)], lcpm_temp)
#3. Melting data in order to create plottable data
DT_lcpm_notNormalised_melt <- melt.data.table(DT_lcpm_notNormalised, id.vars=c("ENSEMBL_ID", "SYMBOL"), variable.name = "ID")
DT_lcpm_melt <- melt.data.table(DT_lcpm, id.vars=c("ENSEMBL_ID", "SYMBOL"), variable.name = "ID")

#4. Plotting function for gene expression distribution
log_cpm_distribution_function <- function(dataset, type){
  log_cpm_distribution_plot <- ggplot(dataset, aes(ID, value, color=ID))+
  geom_jitter(DT_lcpm_notNormalised_melt[,.(value=sample(value, 10000)), by="ID"], mapping=aes(ID, value), alpha=0.05)+
  geom_boxplot(size=1, color="black", alpha=0)+

  scale_y_continuous(limits=c(-8,20), breaks=seq(-10,20,2))+
  scale_fill_manual(values=diverge_hcl(28, c=100, l=c(50,90), power=1), name="Sample:")+
  scale_color_manual(values=diverge_hcl(28, c=100, l=c(50,90), power=1), name="Sample:")+
    
  theme(legend.position="none", axis.title=element_blank(), axis.text.x=element_text(size=10, angle=90))+
  annotate("text", x=11.5, y=18, label=type, size=7.5, alpha=0.6)

  return(log_cpm_distribution_plot)
}

###SECTION OUTPUT
grid.arrange(arrangeGrob(log_cpm_distribution_function(DT_lcpm_notNormalised_melt, "RAW"), left=textGrob("A", vjust=-10, hjust=1.5, gp=gpar(fontface=2, fontsize=20))), arrangeGrob(log_cpm_distribution_function(DT_lcpm_melt, "NORMALIZED"), left=textGrob("B", vjust=-10, hjust=1.5, gp=gpar(fontface=2, fontsize=20))), ncol=2, bottom=textGrob("Sample", gp=gpar(fontsize=17, fontface="bold")), left=textGrob("log-CPM", gp=gpar(fontsize=17, fontface="bold"), rot=90))

```

**Fig 2.** _Figure reports the distribution of gene expression (log-CPM) for each sample. Fig 2A reports the distribution prior to normalization while Fig 2B reports the distribution following normalization of library sizes using the TMM algorithm. Boxplots are based on all log-CPM values while points represent a random sample of 1e4 genes (due to processing time issues). The difference in the distribution of log-CPM using original and effective library sizes is minor but adjusted for._

***

# Dimensionality Reduction

**Fig 3. Variance explained by principal components based on the 500 genes with highest variance**

```{r echo=F, warning=F, message=F, error=F, fig.height=6, fig.width=12}
#1. Calculating the variance between samples within each gene
gene_variance <- data.table(DT_lcpm[,c(1:2)], variance=apply(DT_lcpm[,-(1:2)], 1, var))
#2. Selecting the 500 genes with the highest inter-sample variance 
gene_variance_top500 <- gene_variance[order(-variance)][1:500]
#3. Calculating principal components for the genes with highest variance (top 500) from DT_lcpm
setkey(DT_lcpm, ENSEMBL_ID)
DT_principal_comp_raw <- prcomp(t(DT_lcpm[ENSEMBL_ID %in% gene_variance_top500[,ENSEMBL_ID],-(1:2)]))
DT_principal_comp_summary <- data.table(sd=summary(DT_principal_comp_raw)$sdev)
#4. Subsetting data from raw PC-object for plotting
DT_principal_comp <- data.table(ID=factor(rownames(DT_principal_comp_raw$x)), DT_principal_comp_raw$x)
#5. Merging with meta data
DT_principal_comp <- merge(DT_principal_comp, DT_meta_data[,.(ID, group)], by="ID")
#6. Calculating proportion of explained variance for each component
DT_principal_comp_summary <- DT_principal_comp_summary[,var:=sd**2][,var.prop:=var/sum(var)][,var.prop.cumsum:=cumsum(var.prop)]

#7. Plotting function: proportion of variance explained by each component (proportional/cumulative)
PCA_plot_prop.var_function <- function(dataset, yvariable, color){
  explained_var_plot <- ggplot(dataset, aes(1:19, get(yvariable)))+
  geom_bar(stat="identity", fill=brewer.pal(11, "RdBu")[color], alpha=0.9, width=0.7)+
  geom_point(size=4, shape=18)+
  geom_line(linetype=2, size=1.5)+
  geom_text(aes(label=format(round(get(yvariable), 2), digits=2)), vjust=-1, fontface="bold", size=3)+
  
  scale_x_discrete(limits=seq(1,19,1))+
  scale_y_continuous(breaks=seq(0,1,0.1), limits=c(0,1.1))+
  theme(axis.title=element_blank())
  
  if(yvariable=="var.prop"){
    explained_var_plot <- explained_var_plot +  annotate(geom="text", x=11.5, y=1.1, label="PROPORTIONAL", size=6, alpha=0.6)
  } else if(yvariable=="var.prop.cumsum"){
    explained_var_plot <- explained_var_plot + annotate(geom="text", x=11.5, y=1.1, label="CUMULATIVE", size=6, alpha=0.6)
  }
  
  return(explained_var_plot)
}

#8. Selecting the 500 genes with highest variance from the log-CPM matrix
DT_pca_sim <- DT_lcpm[ENSEMBL_ID %in% gene_variance_top500[,ENSEMBL_ID],-(1:2)]
#9. Boostrapping proportion of variance for each principal component   
DT_pca_boot_conf <- boot(DT_pca_sim, function(dataset, b){summary(prcomp(t(dataset[b])))$importance[2,]}, 1000)
#10. Extracting 95 % confidence intervals from bootstrapped data
DT_pca_boot_conf_summary <- suppressWarnings(data.table(do.call(rbind, lapply(1:10, function(column){boot.ci(DT_pca_boot_conf, type="bca", index=column)$bca[(4:5)]}))))
names(DT_pca_boot_conf_summary) <- c("CI.Lower", "CI.Upper")
#11. Converting bootstrapped data into plotable data 
DT_pca_boot_conf_plotdata <- data.table(DT_pca_boot_conf$t)[, 1:10]
names(DT_pca_boot_conf_plotdata) <- names(DT_pca_boot_conf$t0)[1:10]
DT_pca_boot_conf_plotdata <- suppressWarnings(melt.data.table(DT_pca_boot_conf_plotdata, variable.name = "PC.type"))

###SECTION OUTPUT
grid.arrange(arrangeGrob(PCA_plot_prop.var_function(DT_principal_comp_summary,"var.prop", 1), left=textGrob("A", vjust=-13, hjust=2, gp=gpar(fontface=2, fontsize=20))), arrangeGrob(PCA_plot_prop.var_function(DT_principal_comp_summary,"var.prop.cumsum", 11), left=textGrob("B", vjust=-13, hjust=2, gp=gpar(fontface=2, fontsize=20))), ncol=2, bottom=textGrob("Principal component", gp=gpar(fontsize=17, fontface="bold")), left=textGrob("Proportion variance explained", gp=gpar(fontface="bold", fontsize=17), rot=90))

```

**Fig 3.** _Figure reports the proportion variance explained by each principal component. Fig 3A reports the proportional variance explained by each component while Fig 3B reports the cumulative variance explained by the components._

**Table 2. Upper and lower bounds (bootstrapped 95 % confidence intervals) for the proportion of variance explained by principal component 1 to 10**

```{r echo=F, warning=F, message=F, error=F, fig.height=6, fig.width=12}
kable(data.table("bound"=c("Upper bound:", "Lower bound:"), t(round(DT_pca_boot_conf_summary, 3))), col.names=c(" ", paste(rep("PC", 10), 1:10, sep="")), align="c")
```

```{r echo=F, warning=F, message=F, error=F}
#1. Calculation of Barnes-Hut t-Distributed Stochastic Neighbor Embedding
DT_tSNE_raw <- t(DT_lcpm[ENSEMBL_ID %in% gene_variance_top500[, ENSEMBL_ID],-(1:2)])
DT_tSNE <- Rtsne(as.matrix(DT_tSNE_raw), check_duplicates=FALSE, pca=TRUE, perplexity=3, theta=0.5, dims=3)
tSNE_plot_data <- data.table(DT_tSNE$Y, group=DT_meta_data[, group], ID=DT_meta_data[, ID])

```

```{r echo=F, warning=F, message=F, error=F, fig.height=6, fig.width=10}
#1. Creating group name variable
group_names <- c("invitro", "Naive&NPC[2w]", "Naive&NPC[3w]", "SCI&NPC[2w]", "SCI&NPC[3w]")
#2. Creating color palette for usage in plots downstream
color_palette <- brewer.pal(11, "RdBu")[c(1,2,4,10,11)]
#3. Creating ellipse data
#[PCA]
ellipse_data_PCA <- suppressWarnings(do.call(rbind,lapply(split(DT_principal_comp, DT_principal_comp[,group]), function(group.object){data.table(group=group.object[,group], with(group.object, ellipse::ellipse(cor(PC1,PC2), scale = c(sd(PC1), sd(PC2)), centre=c(mean(PC1), mean(PC2)), t=1.5)))})))
#[tSNE]
ellipse_data_tSNE <- suppressWarnings(do.call(rbind,lapply(split(tSNE_plot_data, tSNE_plot_data[,group]), function(group.object){data.table(group=group.object[,group], with(group.object, ellipse::ellipse(cor(V1,V2), scale = c(sd(V1), sd(V2)), centre=c(mean(V1), mean(V2)), t=1.5)))})))

#4. 2D plot [PCA]
PCA_plot <- ggplot(DT_principal_comp, aes(PC1, PC2))+
  geom_segment(aes(x=DT_principal_comp[, min(PC1)]*1.2, xend=DT_principal_comp[, max(PC1)]*1.2, y=0, yend=0), size=0.2)+
  geom_segment(aes(x=0, xend=0, y=DT_principal_comp[, min(PC2)]*1.2, yend=DT_principal_comp[, max(PC2)]*1.2), size=0.2)+
  geom_polygon(ellipse_data_PCA, mapping=aes(x, y, fill=group), alpha=0.2, show.legend=F)+
  geom_point(aes(color=group, shape=group), size=7, alpha=0.8)+

  xlab("PC1")+
  ylab("PC2")+
  
  scale_color_manual(values=color_palette, labels=group_names)+
  scale_shape_manual(values=c(15:19), labels=group_names)+
  scale_fill_manual(values=color_palette, labels=group_names)+
  scale_x_continuous(breaks=seq(-100, 150, 20))+
  scale_y_continuous(breaks=seq(-50, 50, 10))+
  
  theme(legend.title = element_blank(), legend.position = "none", legend.text=element_text(size=20), legend.justification="center", axis.title=element_text(size=22, face="bold"), axis.line=element_blank(), axis.ticks=element_blank())+
  
  annotate("text", x=DT_principal_comp[group=="SCI:2W", mean(PC1)]+20, y=DT_principal_comp[group=="SCI:2W", mean(PC2)], label="SCI&NPC[2w]", size=4, fontface=2)+
  annotate("text", x=DT_principal_comp[group=="Naive:2W", mean(PC1)], y=DT_principal_comp[group=="Naive:2W", mean(PC2)]-15, label ="Naive&NPC[2w]", size=4, fontface=2)+
  annotate("text", x=DT_principal_comp[group=="SCI:3W", mean(PC1)], y=DT_principal_comp[group=="SCI:3W", mean(PC2)]-12, label="SCI&NPC[3w]", size=4, fontface=2)+
  annotate("text", x=DT_principal_comp[group=="Naive:3W", mean(PC1)], y=DT_principal_comp[group=="Naive:3W", mean(PC2)]+15, label="Naive&NPC[3w]", size=4, fontface=2)+
  annotate("text", x=DT_principal_comp[group=="invitro", mean(PC1)], y=DT_principal_comp[group=="invitro", mean(PC2)]+10, label="In vitro", size=4, fontface=2)+
  
  annotate(geom="text", x=0, y=0, label="PCA", size=10, fontface=2, alpha=0.7)


#5. 2D plot [tSNE]
tSNE_plot <- function(legend_status){
  plot_out <- ggplot(tSNE_plot_data, aes(V1, V2))+
  geom_segment(aes(x=tSNE_plot_data[, min(V1)]*1.2, xend=tSNE_plot_data[, max(V1)]*1.2, y=0, yend=0), size=0.2)+
  geom_segment(aes(x=0, xend=0, y=tSNE_plot_data[, min(V2)], yend=tSNE_plot_data[, max(V2)]), size=0.2)+
  geom_polygon(ellipse_data_tSNE, mapping=aes(x, y, fill=group), alpha=0.2, show.legend=F)+
  geom_point(aes(color=group, shape=group), size=7, alpha=0.8)+

  xlab("V1")+
  ylab("V2")+
  
  scale_color_manual(values=color_palette, labels=group_names)+
  scale_shape_manual(values=c(15:19), labels=group_names)+
  scale_fill_manual(values=color_palette, labels=group_names)+
  scale_x_continuous(breaks=seq(-100, 150, 20))+
  scale_y_continuous(breaks=seq(-100, 100, 20))+
  
  theme(legend.title=element_blank(), legend.position=legend_status, legend.text=element_text(size=20), legend.justification="center", axis.title=element_text(size=22, face="bold"), axis.line=element_blank(), axis.ticks=element_blank())+
  
  annotate(geom="text", x=0, y=0, label="t-SNE", size=10, fontface=2, alpha=0.7)
  
  return(plot_out)
}

```

**Fig 5. Dimensionality reduction using PCA and t-SNE of the 500 genes with highest variance**

```{r echo=F, warning=F, message=F, error=F, fig.height=6, fig.width=12}
#Plotting 2D dimension reduction graphs (PCA, tSNE)
PCA_tSNE_legend <- get_legend(tSNE_plot("bottom"))
grid.arrange(arrangeGrob(arrangeGrob(PCA_plot, tSNE_plot("none"), ncol=2), PCA_tSNE_legend, nrow=2, heights=c(6,1)))

```

**Fig 5.** _Figure reports the samples in low dimensional space following dimensionality reduction with PCA and t-SNE for the 500 genes with the highest variance. Ellipses are added to the samples for easier recognition of the study groups._

***

#Clustering Algorithms

**Fig 9. Hierarchical clustering of samples using 500 most variable genes**

```{r echo=F, warning=F, message=F, error=F, fig.height=6, fig.width=14}
train <- sample(1:nrow(DT_principal_comp), round(0.5*nrow(DT_principal_comp)))

#1. K-Nearest Neighbour (KNN) (2 neighbours)
knn_function <- function(data_set){
  knn_predict <- class::knn(data_set[train, !"group"], data_set[-train, !"group"], cl=data_set[train, group], k=2)
  data_set[-train, knn:=knn_predict]
  return(data_set[, as.integer(knn)])}

KNN_PCA <- knn_function(DT_principal_comp[, c(1:4, 21)])
KNN_tSNE <- knn_function(tSNE_plot_data)

#2. Affinity Propagation (AP)
affinity_propagation_function <- function(dataset){
  ap_fit <- apcluster(negDistMat(r=2), dataset[, names(dataset)%in%c("PC1", "PC2", "PC3", "V1", "V2", "V3"), with=F])
  names(ap_fit@clusters[[1]]) <- NULL
  cl_1 <- ap_fit@clusters[[1]] ; cl_2 <- ap_fit@clusters[[2]] ; cl_3 <- ap_fit@clusters[[3]]
  out <- rbind(dataset[cl_1][, AP:=1], dataset[cl_2][, AP:=2], dataset[cl_3][, AP:=3])
  return(out)}

AP_PCA <- affinity_propagation_function(DT_principal_comp[, c(1:4, 21)])
AP_tSNE <- affinity_propagation_function(tSNE_plot_data)

#3. K-means Clustering (3 centers, 20 starts)
k_means_PCA <- kmeans(DT_principal_comp[, c(2:4)], centers=3, nstart = 20)$cluster
k_means_tSNE <- kmeans(tSNE_plot_data[, 1:3], centers=3, nstart = 20)$cluster

#4. Support Vector Machine (SVM)
svm_function <- function(dataset, formula){
  svm_fit <- svm(formula, data=dataset[train])
  svm_pred <- predict(svm_fit, dataset[-train])
  out <- dataset[-train, svm:=svm_pred][, as.integer(svm)] 
  return(out)}

SVM_PCA <- svm_function(DT_principal_comp[, c(1:4, 21)], formula(group~PC1+PC2+PC3))
SVM_tSNE <- svm_function(tSNE_plot_data, formula(group~V1+V2+V3))

#Creating cluster datasets
PCA_cluster_data <- cbind(DT_principal_comp[, c(1:4, 21)], KM=k_means_PCA, KNN=KNN_PCA, SVM=SVM_PCA)
PCA_cluster_data <- merge(PCA_cluster_data, AP_PCA[, .(ID, AP)], by="ID")

tSNE_cluster_data <- cbind(tSNE_plot_data, KM=k_means_tSNE, KNN=KNN_tSNE, SVM=SVM_tSNE)
tSNE_cluster_data <- merge(tSNE_cluster_data, AP_PCA[, .(ID, AP)], by="ID")

#5. Hierarchical clustering: 500 genes with highest variance

#1. Selecting the 1000 most variable genes (500 to low to separate the remaining two in-vitro samples)
gene_variance_top1000 <- gene_variance[order(-variance)][1:1000]
#1. Creating a dissimilarity structure for the 500 genes with highest variance
setkey(DT_lcpm, ENSEMBL_ID)
DT_dist <- dist(t(DT_lcpm[ENSEMBL_ID %in% gene_variance_top1000[,ENSEMBL_ID],-(1:2)]))
#2. Hierarchical clustering on the dissimilarity structure
DT_hclust <- hclust(DT_dist)

#8B. Circular packing representation
#1. Creating a phylo-object from a hclust-object
DT_hclust_phylo <- as.phylo(DT_hclust)
DT_hclust_edges <- DT_hclust_phylo$edge
#2. Creating data frame and graph data from the data frame
DT_hclust_circularpacking <- data.frame(from=DT_hclust_edges[,1], to=DT_hclust_edges[,2])
DT_hclust_circularpacking <- graph_from_data_frame(DT_hclust_circularpacking)
#3. Create and arrange for addition of group and ID to the data frame
circular_packing_data_adjust  <- function(data_set, n_samples, left_to_right_ID){
  leaf_labels <- data.table(ID=c(rep(NA, length(V(data_set)$name)-n_samples), left_to_right_ID))
  leaf_labels[, "ID"] <- factor(leaf_labels[, ID])
  leaf_labels <- merge(leaf_labels, DT_meta_data[, .(ID, group)], by="ID", sort=F, all=T)

  leaf_labels[,"ID"] <- as.integer(as.character(leaf_labels[,ID]))
  leaf_labels[,"group"] <- as.character(leaf_labels[,group])

  V(data_set)$ID <- leaf_labels$ID
  V(data_set)$group <- leaf_labels$group
  return(data_set)
}

#4. Adjusting data frame prior to plotting (adding leaf numbers manually from dendrogram) 
DT_hclust_circularpacking <- circular_packing_data_adjust(DT_hclust_circularpacking, 19, c(123, 121, 122, 124, 115, 113, 114, 116, 118, 117, 119, 120, 127, 126, 125, 128, 109, 110, 112))

#5. Creating the circular packing plot
color_palette_RdBu <- brewer.pal(11, "RdBu")[c(1:4, 9:11)]

hierarchical_clustering_circular_1000 <- ggraph(DT_hclust_circularpacking, layout='circlepack')+
  geom_node_circle(aes(fill = as.factor(depth), color = as.factor(depth)), alpha=0.6)+
  scale_fill_manual(values=c("0"="white", "1"="white", "2"=color_palette_RdBu[2], "3"=color_palette_RdBu[3], "4"=color_palette_RdBu[4], "5"=color_palette_RdBu[5], "6"=color_palette_RdBu[6]))+
  scale_color_manual(values=c("0" = "white", "1" = "white", "2" = color_palette_RdBu[2], "3" = color_palette_RdBu[3], "4"=color_palette_RdBu[4], "5"=color_palette_RdBu[5], "6"=color_palette_RdBu[6]))+
  
  theme_void()+
  theme(legend.position="FALSE")+
  geom_node_text(aes(label=group, filter=leaf), size=2.5, fontface=2)

### SECTION OUTPUT
par(mfrow=c(1,2))

grid.arrange(arrangeGrob(
arrangeGrob(grob(myplclust(DT_hclust, labels=paste(DT_meta_data[,group]," ","(", DT_meta_data[,ID],")", sep=""), main="", ylab="", lab.col=color_palette[as.numeric(DT_meta_data[,group])], font=2, cex=1, hang=0.05)), left=textGrob("A", vjust=-9, hjust=0, gp=gpar(fontface=2, fontsize=20))),

arrangeGrob(hierarchical_clustering_circular_1000, left=textGrob("B", vjust=-9, hjust=0, gp=gpar(fontface=2, fontsize=20))), ncol=2))

```

**Fig 9.** _Figure reports hierarchical clustering based on the 500 most variable genes. Fig 9A reports the clustering using a dendrogram while Fig 9B reports the same clustering using a circular packing plot._

**Fig 10. Clustering of samples using common methods following dimensionality reduction with PCA and t-SNE**

```{r echo=F, warning=F, message=F, error=F, fig.width=12, fig.height=6}
#Aligning column names
setnames(PCA_cluster_data, c("PC1", "PC2", "PC3"), c("V1", "V2", "V3"))

#2. Function which plots data following dimensionality reduction
dimension_plot_function <- function(data_set, dim_reduction_type, legend.position="none", textboolean=TRUE, cluster_type="none") {
  if(cluster_type!="none"){data_set <- data_set[!is.na(get(cluster_type))]}
  
  dim_plot <- ggplot(data_set, aes(V1, V2))+
    geom_segment(aes(x=data_set[, mean(range(V1))], xend=data_set[, mean(range(V1))], y=data_set[, min(V2)]*1.2, yend=data_set[, max(V2)]), color="black", size=0.1, alpha=0.5)+
    geom_segment(aes(x=data_set[, min(V1)]*1.2, xend=data_set[, max(V1)]*1.2, y=data_set[, mean(range(V2))], yend=data_set[, mean(range(V2))]), color="black", size=0.1, alpha=0.5)+
    
    theme(legend.title=element_blank(), legend.position=legend.position, legend.text=element_text(size=17), legend.justification="center", axis.title=element_blank(), axis.text=element_blank(), axis.line=element_blank(), axis.ticks=element_blank())+
    
    scale_shape_manual(values=c(15:19), labels=group_names)+
    
    annotate(geom="text", x=data_set[, mean(range(V1))], y=data_set[, mean(range(V2))], label=dim_reduction_type, size=7, fontface=2, alpha=0.7)
  
    if(cluster_type=="none"){dim_plot <- dim_plot + 
      geom_point(aes(color=group, shape=group), size=7, alpha=0.7)+
      scale_color_manual(values=color_palette, labels=group_names)}
  
    if(cluster_type!="none"){dim_plot <- dim_plot + 
      geom_point(aes(color=factor(get(cluster_type)), shape=group), size=10, alpha=0.7)+
      scale_color_manual(values=color_palette, labels=c("C1", "C2", "C3"))}
    
    if(textboolean==T){dim_plot <- dim_plot + geom_text(aes(label=ID), show.legend = F, color="black", size=3)}
   
  return(dim_plot)
}

cluster_legend <- get_legend(dimension_plot_function(PCA_cluster_data, "", cluster_type = "KNN", legend.position = "bottom"))

#K-Means Clustering
grid.arrange(arrangeGrob(arrangeGrob(dimension_plot_function(PCA_cluster_data, "K-Means Clustering (3Cs)\n[PCA]", cluster_type = "KM"), left=textGrob("E", vjust=-9, hjust=-3, gp=gpar(fontface=2, fontsize=20))), arrangeGrob(dimension_plot_function(tSNE_cluster_data, "K-Means Clustering (3Cs)\n[tSNE]", cluster_type = "KM"), left=textGrob("F", vjust=-9, hjust=-3, gp=gpar(fontface=2, fontsize=20))), ncol=2), cluster_legend, nrow=2, heights=c(5,1))
#Affinity Propagation
grid.arrange(arrangeGrob(arrangeGrob(dimension_plot_function(PCA_cluster_data, "Affinity Propagation\n[PCA]", cluster_type = "AP"), left=textGrob("K", vjust=-9, hjust=-3, gp=gpar(fontface=2, fontsize=20))), arrangeGrob(dimension_plot_function(tSNE_cluster_data, "Affinity Propagation\n[tSNE]", cluster_type = "AP"), left=textGrob("L", vjust=-9, hjust=-3, gp=gpar(fontface=2, fontsize=20))), ncol=2), cluster_legend, nrow=2, heights=c(5,1))

```

**Fig 10.** _Figure reports result of common clustering algorithms implemented on samples following dimensionality reduction using PCA and t-SNE. In the case train-test split was required a 60:40 ratio (13:9 samples) was used instead of a traditional 80:20 ratio due to low number of samples in the test set._

**Fig 12. Top ten loadings (absolute value) for the first two principal components**

```{r echo=F, warning=F, message=F, error=F, fig.height=6, fig.width=14}
#1. Selecting PC1 and PC2 and adding gene names 
DT_loadings <- data.table(SYMBOL=gene_variance_top500[,SYMBOL], DT_principal_comp_raw$rotation[,(1:2)])
#2. Creating table data
DT_loadings_sub_function <- function(data.load, pc.type, n){
  load_out <- data.load[,.(SYMBOL, get(pc.type))][order(V2)]
  load_out <- rbind(tail(load_out, n), head(load_out, n))
  load_out[,"V2"] <- round(load_out[, V2],3)
  load_out <- load_out[ ,PC.type:=pc.type]
  names(load_out) <- c("Gene", "PC.value", "PC.type")
  return(load_out)  
}

DT_loadings_plotdata <- rbind(DT_loadings_sub_function(DT_loadings[!is.na(SYMBOL)],"PC1", 10), DT_loadings_sub_function(DT_loadings[!is.na(SYMBOL)],"PC2", 10))
#3. Adding a type variable for plotting purposes
DT_loadings_plotdata <- DT_loadings_plotdata[,sign.type:=factor(ifelse(PC.value>0,"pos","neg"))]
#4. Plotting function [traditional barplot]
DT_loadings_plot_function <- function(data.set.loading, pc.type){
  data.set.loading <- data.set.loading[PC.type==pc.type]
  data.set.loading[,"Gene"] <- factor(data.set.loading[, Gene], levels=unique(data.set.loading[,Gene]))
  
  DT_loadings_out <- ggplot(data.set.loading, aes(Gene, PC.value, fill=PC.type))+
  geom_bar(aes(alpha=sign.type), stat="identity", show.legend = F)+
  geom_text(data.set.loading[PC.value>0], mapping=aes(label=round(PC.value,2)), hjust=-0.5, fontface=2, size=5)+
  geom_text(data.set.loading[PC.value<0], mapping=aes(label=round(PC.value,2)), hjust=1.5, fontface=2, size=5)+
  geom_segment(aes(x=0, xend=20, y=0, yend=0), size=2, linetype=2)+
  coord_flip()+
  
  scale_y_continuous(breaks=seq(-0.25, 0.25, 0.05), limits=c(-0.3, 0.3))+
  scale_alpha_manual(values=c(0.7,0.9))+
  
  theme(axis.text.x = element_text(size=12), axis.title.x = element_text(face="bold", size=22), axis.title.y = element_blank(), axis.text.y = element_text(size=15))
  
  if(pc.type=="PC1"){
    DT_loadings_out <- DT_loadings_out+scale_fill_manual(values=brewer.pal(11, "RdBu")[1])+ ylab("Principal component 1")
  } else if(pc.type=="PC2"){
    DT_loadings_out <- DT_loadings_out+scale_fill_manual(values=brewer.pal(11, "RdBu")[11])+ylab("Principal component 2")
  }
  
  return(DT_loadings_out)
}

###SECION OUTPUT
grid.arrange(arrangeGrob(DT_loadings_plot_function(DT_loadings_plotdata, "PC1"), left=textGrob("A", vjust=-12, hjust=1.5, gp=gpar(fontsize=20, fontface=2))), arrangeGrob(DT_loadings_plot_function(DT_loadings_plotdata,"PC2"), left=textGrob("B", vjust=-12, hjust=0, gp=gpar(fontsize=20, fontface=2))), ncol=2, left=textGrob("Gene", gp=gpar(fontface="bold", fontsize=17), rot=90))

```

**Fig 12.** _Figure reports the top 10 positive and negative loadings for the first -and second principal component._

***

# Linear Modelling and Empirical Bayes Moderation Using Precision Weights 

**Fig 15. Mean-variance relationship pre -and post voom transformation**

```{r echo=F, warning=F, message=F, error=F, fig.height=4, fig.width=12}
#1. Setting up a design matrix (a dummy matrix indicating which group each sample belongs to)
DT_design <- model.matrix(~0+DT_meta_data[,group])
colnames(DT_design) <- c("invitro", "Naive_2w", "Naive_3w", "SCI_2w", "SCI_3w")

#2. Setting up a contrast matrix for pairwise comparisons
DT_contrast <- makeContrasts(
  invitro_Naive_2w = invitro-Naive_2w,
  invitro_Naive_3w = invitro-Naive_3w,
  invitro_SCI_2w = invitro-SCI_2w,
  invitro_SCI_3w = invitro-SCI_3w,
  Naive_2w_Naive_3w = Naive_2w-Naive_3w,
  Naive_2w_SCI_2w = Naive_2w-SCI_2w,
  Naive_2w_SCI_3w = Naive_2w-SCI_3w,
  Naive_3w_SCI_2w = Naive_3w-SCI_2w,
  Naive_3w_SCI_3w = Naive_3w-SCI_3w,
  SCI_2w_SCI_3w = SCI_2w-SCI_3w,
  
  levels = colnames(DT_design)
)

#2. Applying voom (precision weights modelling of mean-variance relationship)
DT_voom_raw <- voom(DT_read_count_filtered[,-(1:2)], lib.size = DT_meta_data[,effective.library.size], save.plot = T)
#3. Fit a linear model for each gene
DT_vfit <- lmFit(DT_voom_raw$E, design = DT_design, weights = DT_voom_raw$weights)
#4. Calculate coefficients and standard errors for each linear model (i.e. gene)
DT_vfit <- contrasts.fit(DT_vfit, contrasts = DT_contrast)
#5. Calculate moderated F & t-statistics, log odds of differential expression using emiprical Bayes moderation for each linear model (i.e. gene)
DT_efit <- eBayes(DT_vfit)
#6. Creating a DT_efit object using limma-trend instead of voom trend
DT_vfit_limmaTrend <- lmFit(DT_lcpm[,-(1:2)], design=DT_design)
DT_vfit_limmaTrend <- contrasts.fit(DT_vfit_limmaTrend, contrasts = DT_contrast)
DT_efit_limmaTrend <- eBayes(DT_vfit_limmaTrend)
#7. Plotting data for mean-variance 
DT_voom_plotdata <- data.table(log.cpm=DT_voom_raw$voom.xy$x,quarter.var=DT_voom_raw$voom.xy$y)
DT_efit_plotdata <- data.table(Amean=DT_efit$Amean, log2.sigma=log2(DT_efit$sigma))

voom_plot <- ggplot(DT_voom_plotdata, aes(log.cpm, quarter.var))+
  geom_point(alpha=0.3)+
  geom_smooth(method="loess", color="red", se=F, linetype=2, size=1.5)+
  
    ylab("Sqrt (St.Dev)")+
  
  scale_x_continuous(breaks=seq(0,18,2))+
  scale_y_continuous(breaks=seq(0,3,0.5), limits=c(0.25,2.5))+

  theme(axis.title.y = element_text(face="bold", size=17), axis.title.x = element_blank())

bayes_plot <- ggplot(DT_efit_plotdata, aes(Amean, log2.sigma))+
  geom_point(alpha=0.3)+
  geom_smooth(method="loess", color="red", se=F, linetype=2, size=1.5, span=1.25)+
  geom_segment(aes(x=-3.5, xend=14.5, y=mean(DT_efit_plotdata[,log2.sigma], na.rm=T), yend=mean(DT_efit_plotdata[,log2.sigma], na.rm=T)), color="dodgerblue2", size=1.5, alpha=0.5)+
  
  ylab("log2 (St.Dev)")+
  
  scale_x_continuous(breaks=seq(-2,14,2))+
  scale_y_continuous(breaks=seq(-4,4,0.5), limits=c(-2.5,2.5))+

  theme(axis.title.y = element_text(face="bold", size=17), axis.title.x = element_blank())

###SECTION OUTPUT
grid.arrange(arrangeGrob(arrangeGrob(voom_plot, left=textGrob("A", vjust=-10, hjust=-1.5, gp=gpar(fontsize=20, fontface=2))), arrangeGrob(bayes_plot, left=textGrob("B", vjust=-10, hjust=-1.5, gp=gpar(fontsize=20, fontface=2))), ncol=2), bottom=textGrob("Average log-CPM", gp=gpar(fontsize=17, fontface="bold")))

```

**Fig 15.** _Figure reports the mean-variance relationship pre -and post application of the voom function. Fig 15A reports the average log-CPM against the quarter root of the variance. Fig 15B reports average log-CPM against the $log_2(st.dev)$. Blue line reports the average $log_2(st.dev)$. The red line is a linear trend fitted to the black dots. Each black dot represents a gene. Fig 15A illustrates that the variance is decresing when the average expression is increasing. In Fig 15B the dependency is removed and the mean variance is unchanged when the average expression increases._      

**Fig 16. Hierarchical clustering and circular packing plot of 1000 genes with highest F-value**

```{r echo=F, warning=F, message=F, error=F, fig.width=14, fig.height=6}
#Hierarchical clustering of the 1000 genes with highest F-value
#1. Calculating F-statistica
DT_toptableF <- data.table(topTableF(DT_efit, number=Inf, genelist = DT_read_count_filtered[,SYMBOL]))
#2. Subsetting the 500 genes with the highest F-statistica
DT_toptableF <- DT_toptableF[!is.na(ProbeID)][1:1500, ProbeID]
#3. Retrieving log-CPM values for the genes
DT_toptableF <- DT_lcpm[DT_lcpm[,SYMBOL] %in% DT_toptableF]
#4. Creating a dissimilarity matrix
DT_toptableF <- dist(t(DT_toptableF[,-(1:2)]))
#5. Hierarchical clustering  
DT_toptableF <- hclust(DT_toptableF)
#6. Creating dataset for circular packing plot
DT_toptableF_phylo <- as.phylo(DT_toptableF)
DT_toptableF_edges <- DT_toptableF_phylo$edge
#7. Creating data frame and graph data from the data frame
DT_toptableF_circularpacking <- data.frame(from=DT_toptableF_edges[,1], to=DT_toptableF_edges[,2])
DT_toptableF_circularpacking <- graph_from_data_frame(DT_toptableF_circularpacking)
#8. Adding ID and group identities to data frame 
DT_toptableF_circularpacking <- circular_packing_data_adjust(DT_toptableF_circularpacking, 19, c(126, 127, 125, 128, 109, 110, 112, 118, 117, 119, 120, 115, 113, 114, 116, 123, 121, 122, 124))

hierarchical_clustering_circular_Fstatistica <- ggraph(DT_toptableF_circularpacking, layout='circlepack')+
  geom_node_circle(aes(fill = as.factor(depth), color = as.factor(depth)), alpha=0.6)+
  scale_fill_manual(values=c("0"="white", "1"="white", "2"=color_palette_RdBu[2], "3"=color_palette_RdBu[3], "4"=color_palette_RdBu[4], "5"=color_palette_RdBu[5], "6"=color_palette_RdBu[6], "7"=color_palette_RdBu[7], "8"=color_palette_RdBu[8]))+
  scale_color_manual(values=c("0" = "white", "1" = "white", "2" = color_palette_RdBu[2], "3" = color_palette_RdBu[3], "4"=color_palette_RdBu[4], "5"=color_palette_RdBu[5], "6"=color_palette_RdBu[6], "7"=color_palette_RdBu[7], "8"=color_palette_RdBu[8]))+
  
  theme_void()+
  theme(legend.position="FALSE")+
  geom_node_text(aes(label=group, filter=leaf), size=2, fontface=2)

###SECTION OUTPUT
par(mfrow=c(1,2))

grid.arrange(arrangeGrob(

arrangeGrob(grob(myplclust(DT_toptableF, labels = paste(DT_meta_data[,group]," ","(", DT_meta_data[,ID], ")", sep=""), lab.col = brewer.pal(11,"RdBu")[c(1,2,10,11)][as.numeric(DT_meta_data[,group])], main=" ", ylab=" ", font=2, cex=1, hang=0.05)), left=textGrob("A", vjust=-10, hjust=0, gp=gpar(fontface=2, fontsize=20))),

arrangeGrob(left=textGrob("B", vjust=-10, hjust=0, gp=gpar(fontface=2, fontsize=20)),hierarchical_clustering_circular_Fstatistica), ncol=2))

```

**Fig 16.** _Figure reports hierarchical clustering of samples based on the 1000 genes with highest F-values. Fig 16A reports a dendrogram while Fig 16B reports a circular packing plot._ 

***

# Differential Gene Expression

```{r echo=F, warning=F, message=F, error=F, fig.show='hide'}
#1. Summarizing the number of up - and downregulated differentially expressed genes
DT_dge <- decideTests(DT_efit, adjust.method = "BH")
#2. Converting DT_dge into logical (-1 and 1 is TRUE and 0 is FALSE) 
venn_data_logical <- do.call(cbind, lapply(data.table(DT_dge), function(column){column!=0}))
#3. Function for retrieving data to add to venndiagram
venn_data_function <- function(data.set, c1=NULL, c2=NULL, c3=NULL){
  out <- sum(rowSums(data.set[,c(c1, c2, c3)]) %in% length(c(c1, c2, c3)))
  return(out)}

#2W: Naive vs SCI + invitro
venn_plot_2w <- invisible(draw.triple.venn(sum(venn_data_logical[,1]), 
               sum(venn_data_logical[,3]), 
               sum(venn_data_logical[,6]), 
               venn_data_function(venn_data_logical,1,3),
               venn_data_function(venn_data_logical,3,6),
               venn_data_function(venn_data_logical,1,6),
               venn_data_function(venn_data_logical,1,3,6),
               category=c("Invitro - Naive&NPC[2w]", "Invitro - SCI&NPC[2w]", "Naive&NPC[2w] - SCI&NPC[2w]"),
               lwd=c(2,2,2),
               fill=brewer.pal(11,"RdBu")[c(2,4,9)],
               alpha=0.7,
               cex=1.5,
               cat.cex=1.5,
               cat.col= brewer.pal(11,"RdBu")[c(2,4,9)],
               cat.fontface=2,
               cat.just=list(c(0.6, -6), c(0.5,-6), c(0.5, 6)),
               cat.default.pos = "text",
               margin=c(0.2)))

#3W: Naive vs SCI + invitro
venn_plot_3w <- invisible(draw.triple.venn(sum(venn_data_logical[,2]), 
               sum(venn_data_logical[,4]), 
               sum(venn_data_logical[,9]), 
               venn_data_function(venn_data_logical,2,4),
               venn_data_function(venn_data_logical,4,9),
               venn_data_function(venn_data_logical,2,9),
               venn_data_function(venn_data_logical,2,4,9),
               category=c("Invitro - Naive&NPC[3w]", "Invitro - SCI&NPC[3w]", "Naive&NPC[3w] - SCI&NPC[3w]"),
               lwd=c(2,2,2),
               fill=brewer.pal(11,"RdBu")[c(2,4,9)],
               alpha=0.7,
               cex=1.5,
               cat.cex=1.5,
               cat.col= brewer.pal(11,"RdBu")[c(2,4,9)],
               cat.fontface=2,
               cat.just=list(c(0.6,-6), c(0.5,-6), c(0.5,6)),
               cat.default.pos = "text",
               margin=c(0.2)))

#Between timepoints (2->3w) for Naive vs SCI contrast
venn_plot_2w_3w <- invisible(draw.pairwise.venn(sum(venn_data_logical[,6]), 
               sum(venn_data_logical[,9]), 
               venn_data_function(venn_data_logical,6,9),
               category=c("Naive&NPC[2w] - SCI&NPC[2w]", "Naive&NPC[3w] - SCI&NPC[3w]"),
               lwd=c(2,2),
               fill=brewer.pal(11,"RdBu")[c(2,9)],
               scaled=F,
               alpha=0.7,
               cex=1.5,
               cat.cex=2,
               cat.col= brewer.pal(11,"RdBu")[c(2,9)],
               cat.fontface=2,
               cat.just=list(c(0.8, -6), c(0.3, -6)),
               cat.default.pos = "text"))
               #margin=c(0.3)

```

**Fig 17. Number of differentially expressed genes for each contrast (FDR<0.05)**

```{r echo=F, warning=F, message=F, error=F, fig.width=12, fig.height=6, fig.align='center'}
###SECTION OUTPUT
grid.arrange(arrangeGrob(gTree(children=venn_plot_2w), left=textGrob("A", gp=gpar(fontface="bold", fontsize=20), vjust=-13)), arrangeGrob(gTree(children=venn_plot_2w), left=textGrob("B", gp=gpar(fontface="bold", fontsize=20), vjust=-13)), ncol=2)
```

**Fig 17.** _Figure A reports the number of DGE genes between contrasts Naive[2w] vs invitro, SCI[2w] vs invitro, Naive[2w] vs SCI[2w]. Figure B reports the number of DGE genes between contrasts Naive[2w] vs invitro, SCI[2w] vs invitro and Naive[2w] vs SCI[2w]._

**Fig 18. Number of differentially expressed genes for each contrast (FDR<0.05)**

```{r echo=F, warning=F, message=F, error=F, fig.width=5, fig.height=4, fig.align='center'}
###SECTION OUTPUT
grid.arrange(arrangeGrob(gTree(children=venn_plot_2w_3w)))
```

**Fig 18.** _Figure reports the number of DGE genes within and between contrasts Naive[2w]vsSCI[2w] and Naive[3w]vsSCI[3w]._

**Table 3. Number of differentially over -and under-expressed genes for each contrast (FDR<0.05)**

```{r echo=F, warning=F, message=F, error=F}
#Summary table
DT_dge_summary <- as.data.frame.matrix(summary(DT_dge))
DT_dge_summary <- rbind(DT_dge_summary, colSums(DT_dge_summary))
rownames(DT_dge_summary) <- c("Downregulated:", "No change", "Upregulated:", "Sum:")

kable(DT_dge_summary[,1:4], align="c", col.names = c("Invitro vs Naive[2w]", "Invitro vs Naive[3w]", "Invitro vs SCI[2w]", "Invitro vs SCI[3w]"))

kable(DT_dge_summary[, 5:10], align="c", col.names = c("Naive[2w] vs Naive[3w]", "Naive[2w] vs SCI[2w]", "Naive[2w] vs SCI[3w]", "Naive[3w] vs SCI[2w]", "Naive[3w] vs SCI[3w]", "SCI[2w] vs SCI[3w]"))

```

```{r echo=F, warning=F, message=F, error=F}
# #Within timpepoint
# Naive_2w_SCI_2w #contrast 6
# Naive_3w_SCI_3w #contrast 9
# 
# #Between timepoints
# Naive_2w_Naive_3w #contrast 5
# SCI_2w_SCI_3w #contrast 10

```

```{r echo=F, warning=F, message=F, error=F}
#1. Creating plotting data for mean-difference plot
mean_difference_data_function <- function(contrast){
  out <- data.table(toptable(DT_efit, coef=contrast, number=Inf, genelist = DT_read_count_filtered[,SYMBOL], A=DT_efit$Amean))
  out <- out[!is.na(ID)]
  return(out)}

DT_mean_difference_2w <- mean_difference_data_function(6)
DT_mean_difference_3w <- mean_difference_data_function(9)
DT_mean_difference_Naive <- mean_difference_data_function(5)
DT_mean_difference_SCI <- mean_difference_data_function(10)

#2. Creating data for voclano plot
volcano_data_function <- function(mean_difference_data, contrast){
  volcano_temp <- data.table(DT_read_count_filtered[,SYMBOL], DT_efit$lods[,contrast])
  names(volcano_temp) <- c("ID","log.odds")
  volcano_temp <- volcano_temp[!is.na(ID)]
  DT_volcano <- merge(mean_difference_data, volcano_temp, by="ID")
  return(DT_volcano)  
}

DT_volcano_2w <- volcano_data_function(DT_mean_difference_2w, 6)
DT_volcano_3w <- volcano_data_function(DT_mean_difference_3w, 9)
DT_volcano_Naive <- volcano_data_function(DT_mean_difference_Naive, 5)
DT_volcano_SCI <- volcano_data_function(DT_mean_difference_SCI, 10)

```

```{r echo=F, warning=F, message=F, error=F}
#Mean-difference plot function
mean_difference_plot_function <- function(data_set){
  plot_out <- ggplot(data_set, aes(AveExpr,logFC))+
  geom_jitter(data_set[(logFC>(-1) & logFC<1)], mapping=aes(AveExpr, logFC), alpha=0.7, size=3)+
  geom_jitter(data_set[(logFC<=(-1) | logFC>=1) & adj.P.Val>0.05], mapping=aes(AveExpr, logFC), color="dodgerblue4", alpha=0.8, size=3)+
  geom_jitter(data_set[(logFC<=(-1) | logFC>=1) & adj.P.Val<0.05], mapping=aes(AveExpr, logFC), color="red", alpha=0.5, size=3)+
  geom_segment(aes(x=-5, xend=15, y=-1,yend=-1), size=1.5, color="dodgerblue2", linetype=2)+
  geom_segment(aes(x=-5, xend=15, y=1,yend=1), size=1.5, color="dodgerblue2", linetype=2)+
  
  annotate("text", x=12, y=5.5, label=nrow(data_set[logFC>=1 & adj.P.Val>0.05]), color="dodgerblue4", fontface=2, alpha=0.8, size=4.5)+
    annotate("text", x=12, y=-5.5, label=(nrow(data_set[logFC<=-1 & adj.P.Val>0.05])+2), color="dodgerblue4", fontface=2, alpha=0.8, size=4.5)+

  annotate("text", x=12, y=-3.5, label=(nrow(data_set[logFC<=-1 & adj.P.Val<0.05])+2), color="red", fontface=2, alpha=0.8, size=4.5)+
  annotate("text", x=12, y=3.5, label=nrow(data_set[logFC>=1 & adj.P.Val<0.05]), color="red", fontface=2, alpha=0.8, size=4.5)+

  annotate("text", x=12, y=2, label=nrow(data_set[logFC>=1]), color="grey", fontface=2, size=4.5)+
  annotate("text", x=12, y=-2, label=(nrow(data_set[logFC<=-1])+4), color="grey", fontface=2, size=4.5)+
  
  scale_x_continuous(breaks=seq(-5,15,1))+
  scale_y_continuous(breaks=seq(-20,10,2))+
  
  xlab("Average log-CPM")+
  ylab("Log2(fold change)")+
  
  annotate("text", x=11, y=8, label="UP-REGULATED", fontface=2, alpha=0.6, size=5)+
  annotate("text", x=11, y=-8, label="DOWN-REGULATED", fontface=2, alpha=0.6, size=5)+
  
  theme(axis.title = element_text(face="bold", size=22))
  
  return(plot_out)
}

#Volcano plot function
volcano_plot_function <- function(data_set){
  plot_out <- ggplot(data_set, aes(logFC, log.odds))+
  geom_jitter(data_set[log.odds<1 & (logFC>=1 | logFC<=(-1))], mapping=aes(logFC, log.odds), alpha=0.7, size=3, color="dodgerblue4")+
  geom_jitter(data_set[!(logFC>=1 | logFC<=(-1))], mapping=aes(logFC, log.odds), alpha=0.7, size=3)+
  geom_jitter(data_set[log.odds>1 & (logFC>=1 | logFC<=(-1))], mapping=aes(logFC, log.odds), color="red", alpha=0.5, size=3)+
  
  geom_segment(aes(x=-1, xend=-1, y=-8,yend=8), size=1.5, color="dodgerblue2", linetype=2)+
  geom_segment(aes(x=1, xend=1, y=-8,yend=8), size=1.5, color="dodgerblue2", linetype=2)+
  geom_segment(aes(x=-7, xend=6, y=1, yend=1), size=0.5, color="dodgerblue2")+
  
  scale_y_continuous(breaks=seq(-10,50,5))+
  scale_x_continuous(breaks=seq(-7,6,1), limits=c(-7,6))+
  
  ylab("-log10(p.value)")+
  xlab("Log2(fold change)")+
  
  annotate("text", x=4, y=50, label="UP-REGULATION", fontface=2, alpha=0.6, size=5)+
  annotate("text", x=-4, y=50, label="DOWN-REGULATION", fontface=2, alpha=0.6, size=5)+

  theme(axis.title = element_text(face="bold", size=22))
  
  return(plot_out)
}

```

**Fig 18. Mean difference -and volcano plot (FDR<0.05)**

```{r echo=F, warning=F, message=F, error=F, fig.width=14, fig.height=5}
plot_grid(arrangeGrob(mean_difference_plot_function(DT_mean_difference_2w), left=textGrob("A", vjust=-11, hjust=-2, gp=gpar(fontsize=20, fontface=2))), arrangeGrob(volcano_plot_function(DT_volcano_2w), left=textGrob("B", vjust=-11, hjust=-2, gp=gpar(fontsize=20, fontface=2))))

plot_grid(arrangeGrob(mean_difference_plot_function(DT_mean_difference_3w), left=textGrob("C", vjust=-11, hjust=-2, gp=gpar(fontsize=20, fontface=2))), arrangeGrob(volcano_plot_function(DT_volcano_3w), left=textGrob("D", vjust=-11, hjust=-2, gp=gpar(fontsize=20, fontface=2))))

plot_grid(arrangeGrob(mean_difference_plot_function(DT_mean_difference_Naive), left=textGrob("E", vjust=-11, hjust=-2, gp=gpar(fontsize=20, fontface=2))), arrangeGrob(volcano_plot_function(DT_volcano_Naive), left=textGrob("E", vjust=-11, hjust=-2, gp=gpar(fontsize=20, fontface=2))))

plot_grid(arrangeGrob(mean_difference_plot_function(DT_mean_difference_SCI), left=textGrob("G", vjust=-11, hjust=-2, gp=gpar(fontsize=20, fontface=2))), arrangeGrob(volcano_plot_function(DT_volcano_SCI), left=textGrob("H", vjust=-11, hjust=-2, gp=gpar(fontsize=20, fontface=2))))
```

**Fig 18.** _Right figure reports a mean-difference plot which illustrates the number of over -and under expressed genes. Threshold is set at $log_2(fold change)$ +/-1 (blue lines). Blue dots represents genes above or below the log-fold change thresholds while red dots represent those genes which are above/below the thresholds and are significantly (p<1e-6) differentially expressed. Left figure is a volcano plot which reports the number of significantly (p<1e-6) over -and underexpressed genes (marked with red). Blue dots represent genes which have logFC <-1 or >1 but are not significantly expressed. Figure A&B are for contrast Naive[2w]vsSCI[2w], Figure C&D are for contrast Naive[3w]vsSCI[3w], figure E&F are for contrast Naive[2w]vsNaive[3w] and figure G&H for contrast SCI[2w]vsSCI[3w]._

```{r echo=F, warning=F, message=F, error=F}
#1. Function for retrieving logFC and associated p-values for most over -and underexpressed genes 
top_20_dge_retreiver <- function(dge.data, n, p.val.cutoff, contrast){
  top_20_dge_out <- data.table(toptable(dge.data, coef=contrast, number=Inf, genelist = DT_read_count_filtered[,ifelse(is.na(SYMBOL), ENSEMBL_ID, SYMBOL)]))
  
  negative_logFC <-  data.table(top_20_dge_out[logFC<(-1) & adj.P.Val<p.val.cutoff][order(adj.P.Val)][1:n])
  negative_logFC <- negative_logFC[,.(ID, logFC=round(logFC, 2), adj.P.Val=format(adj.P.Val, scientific=T, digits=2))]

  positive_logFC <- data.table(top_20_dge_out[logFC>1 & adj.P.Val<p.val.cutoff][order(adj.P.Val)][1:n])
  positive_logFC <- positive_logFC[,.(ID, logFC=round(logFC, 2), adj.P.Val=format(adj.P.Val, scientific=T, digits=2))]
  
  return(cbind(positive_logFC, negative_logFC))}

#2. Creating top 20 data for each contrast of interest
top_20_dge_2w <- top_20_dge_retreiver(DT_efit, 10, 0.05, 6)
top_20_dge_3w <- top_20_dge_retreiver(DT_efit, 10, 0.05, 9)
top_20_dge_Naive <- top_20_dge_retreiver(DT_efit, 10, 0.05, 5)
top_20_dge_SCI <- top_20_dge_retreiver(DT_efit, 10, 0.05, 10)

```

**Table 4. 10 most significantly up -and downregulated differentially expressed genes (FDR<0.05)**  

**Contrast: Naive[2w] vs SCI[2w]**

```{r echo=F, warning=F, message=F, error=F}
kable(top_20_dge_2w, align="c", col.names = rep(c("Gene", "log2(fold change)", "P-value (adjusted)"), 2))
```

**Contrast: Naive[3w] vs SCI[3w]**  
```{r echo=F, warning=F, message=F, error=F}
kable(top_20_dge_3w, align="c", col.names = rep(c("Gene", "log2(fold change)", "P-value (adjusted)"), 2))
```

**Contrast: Naive[2w] vs Naive[3w]**  
```{r echo=F, warning=F, message=F, error=F}
kable(top_20_dge_Naive, align="c", col.names = rep(c("Gene", "log2(fold change)", "P-value (adjusted)"), 2))
```

**Contrast: SCI[2w] vs SCI[3w]**  
```{r echo=F, warning=F, message=F, error=F}
kable(top_20_dge_SCI, align="c", col.names = rep(c("Gene", "log2(fold change)", "P-value (adjusted)"), 2))
```

***

#Gene Ontology and KEGG Enrichment Analysis

**Table 5. GO terms and KEGG pathways (FDR<0.05)**

```{r echo=F, warning=F, message=F, error=F}
#1. Getting ENTREZ IDs for all genes in the filtered read count matrix 
entrez_ID <- suppressMessages(data.table(OrganismDbi::select(Rattus.norvegicus, keys=DT_read_count_filtered[,as.character(ENSEMBL_ID)], columns="ENTREZID", keytype="ENSEMBL")))
#2. Removing duplicates
entrez_ID <- entrez_ID[!duplicated(ENSEMBL)]



```

